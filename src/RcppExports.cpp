// Generated by using Rcpp::compileAttributes() -> do not edit by hand
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include "../inst/include/farray.h"
#include <Rcpp.h>
#include <string>
#include <set>

using namespace Rcpp;

// isLittleEndian
bool isLittleEndian();
RcppExport SEXP _farray_isLittleEndian() {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    rcpp_result_gen = Rcpp::wrap(isLittleEndian());
    return rcpp_result_gen;
END_RCPP
}
// loc2idx3
std::vector<int64_t> loc2idx3(SEXP locations, std::vector<int64_t>& parent_dim);
RcppExport SEXP _farray_loc2idx3(SEXP locationsSEXP, SEXP parent_dimSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< SEXP >::type locations(locationsSEXP);
    Rcpp::traits::input_parameter< std::vector<int64_t>& >::type parent_dim(parent_dimSEXP);
    rcpp_result_gen = Rcpp::wrap(loc2idx3(locations, parent_dim));
    return rcpp_result_gen;
END_RCPP
}
// parseSlices
Rcpp::List parseSlices(SEXP listOrEnv, const std::vector<int64_t>& dim, bool pos_subscript);
RcppExport SEXP _farray_parseSlices(SEXP listOrEnvSEXP, SEXP dimSEXP, SEXP pos_subscriptSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< SEXP >::type listOrEnv(listOrEnvSEXP);
    Rcpp::traits::input_parameter< const std::vector<int64_t>& >::type dim(dimSEXP);
    Rcpp::traits::input_parameter< bool >::type pos_subscript(pos_subscriptSEXP);
    rcpp_result_gen = Rcpp::wrap(parseSlices(listOrEnv, dim, pos_subscript));
    return rcpp_result_gen;
END_RCPP
}
// parseAndScheduleBlocks2
Rcpp::List parseAndScheduleBlocks2(SEXP sliceIdx, Rcpp::NumericVector dim, int forceSchedule);
RcppExport SEXP _farray_parseAndScheduleBlocks2(SEXP sliceIdxSEXP, SEXP dimSEXP, SEXP forceScheduleSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< SEXP >::type sliceIdx(sliceIdxSEXP);
    Rcpp::traits::input_parameter< Rcpp::NumericVector >::type dim(dimSEXP);
    Rcpp::traits::input_parameter< int >::type forceSchedule(forceScheduleSEXP);
    rcpp_result_gen = Rcpp::wrap(parseAndScheduleBlocks2(sliceIdx, dim, forceSchedule));
    return rcpp_result_gen;
END_RCPP
}
// reshapeOrDrop
SEXP reshapeOrDrop(SEXP x, SEXP reshape, bool drop);
RcppExport SEXP _farray_reshapeOrDrop(SEXP xSEXP, SEXP reshapeSEXP, SEXP dropSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< SEXP >::type x(xSEXP);
    Rcpp::traits::input_parameter< SEXP >::type reshape(reshapeSEXP);
    Rcpp::traits::input_parameter< bool >::type drop(dropSEXP);
    rcpp_result_gen = Rcpp::wrap(reshapeOrDrop(x, reshape, drop));
    return rcpp_result_gen;
END_RCPP
}
// setFArrayBlockSize
R_xlen_t setFArrayBlockSize(R_xlen_t size, R_xlen_t limit, R_xlen_t buf_size);
static SEXP _farray_setFArrayBlockSize_try(SEXP sizeSEXP, SEXP limitSEXP, SEXP buf_sizeSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< R_xlen_t >::type size(sizeSEXP);
    Rcpp::traits::input_parameter< R_xlen_t >::type limit(limitSEXP);
    Rcpp::traits::input_parameter< R_xlen_t >::type buf_size(buf_sizeSEXP);
    rcpp_result_gen = Rcpp::wrap(setFArrayBlockSize(size, limit, buf_size));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _farray_setFArrayBlockSize(SEXP sizeSEXP, SEXP limitSEXP, SEXP buf_sizeSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_farray_setFArrayBlockSize_try(sizeSEXP, limitSEXP, buf_sizeSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// getFArrayBlockSize
R_xlen_t getFArrayBlockSize(int which);
static SEXP _farray_getFArrayBlockSize_try(SEXP whichSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< int >::type which(whichSEXP);
    rcpp_result_gen = Rcpp::wrap(getFArrayBlockSize(which));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _farray_getFArrayBlockSize(SEXP whichSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_farray_getFArrayBlockSize_try(whichSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// subsetFM
SEXP subsetFM(const std::string& rootPath, SEXP listOrEnv, const std::vector<int64_t>& dim, SEXPTYPE dtype, SEXP reshape, bool drop);
RcppExport SEXP _farray_subsetFM(SEXP rootPathSEXP, SEXP listOrEnvSEXP, SEXP dimSEXP, SEXP dtypeSEXP, SEXP reshapeSEXP, SEXP dropSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const std::string& >::type rootPath(rootPathSEXP);
    Rcpp::traits::input_parameter< SEXP >::type listOrEnv(listOrEnvSEXP);
    Rcpp::traits::input_parameter< const std::vector<int64_t>& >::type dim(dimSEXP);
    Rcpp::traits::input_parameter< SEXPTYPE >::type dtype(dtypeSEXP);
    Rcpp::traits::input_parameter< SEXP >::type reshape(reshapeSEXP);
    Rcpp::traits::input_parameter< bool >::type drop(dropSEXP);
    rcpp_result_gen = Rcpp::wrap(subsetFM(rootPath, listOrEnv, dim, dtype, reshape, drop));
    return rcpp_result_gen;
END_RCPP
}
// getFArrayThread
int getFArrayThread(bool max);
static SEXP _farray_getFArrayThread_try(SEXP maxSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< bool >::type max(maxSEXP);
    rcpp_result_gen = Rcpp::wrap(getFArrayThread(max));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _farray_getFArrayThread(SEXP maxSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_farray_getFArrayThread_try(maxSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// setFArrayThread
int setFArrayThread(int n, SEXP reset_after_fork);
static SEXP _farray_setFArrayThread_try(SEXP nSEXP, SEXP reset_after_forkSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< int >::type n(nSEXP);
    Rcpp::traits::input_parameter< SEXP >::type reset_after_fork(reset_after_forkSEXP);
    rcpp_result_gen = Rcpp::wrap(setFArrayThread(n, reset_after_fork));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _farray_setFArrayThread(SEXP nSEXP, SEXP reset_after_forkSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_farray_setFArrayThread_try(nSEXP, reset_after_forkSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// hasOpenMP
bool hasOpenMP();
static SEXP _farray_hasOpenMP_try() {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    rcpp_result_gen = Rcpp::wrap(hasOpenMP());
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _farray_hasOpenMP() {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_farray_hasOpenMP_try());
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// addTo
SEXP addTo(SEXP x, SEXP y);
RcppExport SEXP _farray_addTo(SEXP xSEXP, SEXP ySEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< SEXP >::type x(xSEXP);
    Rcpp::traits::input_parameter< SEXP >::type y(ySEXP);
    rcpp_result_gen = Rcpp::wrap(addTo(x, y));
    return rcpp_result_gen;
END_RCPP
}
// testt
SEXP testt(std::string file);
RcppExport SEXP _farray_testt(SEXP fileSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< std::string >::type file(fileSEXP);
    rcpp_result_gen = Rcpp::wrap(testt(file));
    return rcpp_result_gen;
END_RCPP
}
// ensurePartition
SEXP ensurePartition(const std::string& file, int64_t length, SEXP na, int size);
RcppExport SEXP _farray_ensurePartition(SEXP fileSEXP, SEXP lengthSEXP, SEXP naSEXP, SEXP sizeSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::RNGScope rcpp_rngScope_gen;
    Rcpp::traits::input_parameter< const std::string& >::type file(fileSEXP);
    Rcpp::traits::input_parameter< int64_t >::type length(lengthSEXP);
    Rcpp::traits::input_parameter< SEXP >::type na(naSEXP);
    Rcpp::traits::input_parameter< int >::type size(sizeSEXP);
    rcpp_result_gen = Rcpp::wrap(ensurePartition(file, length, na, size));
    return rcpp_result_gen;
END_RCPP
}
// dropDimension
SEXP dropDimension(SEXP x);
static SEXP _farray_dropDimension_try(SEXP xSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< SEXP >::type x(xSEXP);
    rcpp_result_gen = Rcpp::wrap(dropDimension(x));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _farray_dropDimension(SEXP xSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_farray_dropDimension_try(xSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// prod2
int64_t prod2(SEXP x, bool na_rm);
static SEXP _farray_prod2_try(SEXP xSEXP, SEXP na_rmSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< SEXP >::type x(xSEXP);
    Rcpp::traits::input_parameter< bool >::type na_rm(na_rmSEXP);
    rcpp_result_gen = Rcpp::wrap(prod2(x, na_rm));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _farray_prod2(SEXP xSEXP, SEXP na_rmSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_farray_prod2_try(xSEXP, na_rmSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// parseDots
SEXP parseDots(Rcpp::Environment& env, bool eval);
static SEXP _farray_parseDots_try(SEXP envSEXP, SEXP evalSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< Rcpp::Environment& >::type env(envSEXP);
    Rcpp::traits::input_parameter< bool >::type eval(evalSEXP);
    rcpp_result_gen = Rcpp::wrap(parseDots(env, eval));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _farray_parseDots(SEXP envSEXP, SEXP evalSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_farray_parseDots_try(envSEXP, evalSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// stopIfNot
bool stopIfNot(const bool isValid, const std::string& message, bool stopIfError);
static SEXP _farray_stopIfNot_try(SEXP isValidSEXP, SEXP messageSEXP, SEXP stopIfErrorSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< const bool >::type isValid(isValidSEXP);
    Rcpp::traits::input_parameter< const std::string& >::type message(messageSEXP);
    Rcpp::traits::input_parameter< bool >::type stopIfError(stopIfErrorSEXP);
    rcpp_result_gen = Rcpp::wrap(stopIfNot(isValid, message, stopIfError));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _farray_stopIfNot(SEXP isValidSEXP, SEXP messageSEXP, SEXP stopIfErrorSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_farray_stopIfNot_try(isValidSEXP, messageSEXP, stopIfErrorSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// getSexpType
SEXPTYPE getSexpType(SEXP x);
static SEXP _farray_getSexpType_try(SEXP xSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< SEXP >::type x(xSEXP);
    rcpp_result_gen = Rcpp::wrap(getSexpType(x));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _farray_getSexpType(SEXP xSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_farray_getSexpType_try(xSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// tik
SEXP tik();
static SEXP _farray_tik_try() {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    rcpp_result_gen = Rcpp::wrap(tik());
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _farray_tik() {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_farray_tik_try());
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}
// tok
SEXP tok(std::string msg, bool stop);
static SEXP _farray_tok_try(SEXP msgSEXP, SEXP stopSEXP) {
BEGIN_RCPP
    Rcpp::RObject rcpp_result_gen;
    Rcpp::traits::input_parameter< std::string >::type msg(msgSEXP);
    Rcpp::traits::input_parameter< bool >::type stop(stopSEXP);
    rcpp_result_gen = Rcpp::wrap(tok(msg, stop));
    return rcpp_result_gen;
END_RCPP_RETURN_ERROR
}
RcppExport SEXP _farray_tok(SEXP msgSEXP, SEXP stopSEXP) {
    SEXP rcpp_result_gen;
    {
        Rcpp::RNGScope rcpp_rngScope_gen;
        rcpp_result_gen = PROTECT(_farray_tok_try(msgSEXP, stopSEXP));
    }
    Rboolean rcpp_isInterrupt_gen = Rf_inherits(rcpp_result_gen, "interrupted-error");
    if (rcpp_isInterrupt_gen) {
        UNPROTECT(1);
        Rf_onintr();
    }
    bool rcpp_isLongjump_gen = Rcpp::internal::isLongjumpSentinel(rcpp_result_gen);
    if (rcpp_isLongjump_gen) {
        Rcpp::internal::resumeJump(rcpp_result_gen);
    }
    Rboolean rcpp_isError_gen = Rf_inherits(rcpp_result_gen, "try-error");
    if (rcpp_isError_gen) {
        SEXP rcpp_msgSEXP_gen = Rf_asChar(rcpp_result_gen);
        UNPROTECT(1);
        Rf_error(CHAR(rcpp_msgSEXP_gen));
    }
    UNPROTECT(1);
    return rcpp_result_gen;
}

// validate (ensure exported C++ functions exist before calling them)
static int _farray_RcppExport_validate(const char* sig) { 
    static std::set<std::string> signatures;
    if (signatures.empty()) {
        signatures.insert("R_xlen_t(*setFArrayBlockSize)(R_xlen_t,R_xlen_t,R_xlen_t)");
        signatures.insert("R_xlen_t(*getFArrayBlockSize)(int)");
        signatures.insert("int(*getFArrayThread)(bool)");
        signatures.insert("int(*setFArrayThread)(int,SEXP)");
        signatures.insert("bool(*hasOpenMP)()");
        signatures.insert("SEXP(*dropDimension)(SEXP)");
        signatures.insert("int64_t(*prod2)(SEXP,bool)");
        signatures.insert("SEXP(*parseDots)(Rcpp::Environment&,bool)");
        signatures.insert("bool(*stopIfNot)(const bool,const std::string&,bool)");
        signatures.insert("SEXPTYPE(*getSexpType)(SEXP)");
        signatures.insert("SEXP(*tik)()");
        signatures.insert("SEXP(*tok)(std::string,bool)");
    }
    return signatures.find(sig) != signatures.end();
}

// registerCCallable (register entry points for exported C++ functions)
RcppExport SEXP _farray_RcppExport_registerCCallable() { 
    R_RegisterCCallable("farray", "_farray_setFArrayBlockSize", (DL_FUNC)_farray_setFArrayBlockSize_try);
    R_RegisterCCallable("farray", "_farray_getFArrayBlockSize", (DL_FUNC)_farray_getFArrayBlockSize_try);
    R_RegisterCCallable("farray", "_farray_getFArrayThread", (DL_FUNC)_farray_getFArrayThread_try);
    R_RegisterCCallable("farray", "_farray_setFArrayThread", (DL_FUNC)_farray_setFArrayThread_try);
    R_RegisterCCallable("farray", "_farray_hasOpenMP", (DL_FUNC)_farray_hasOpenMP_try);
    R_RegisterCCallable("farray", "_farray_dropDimension", (DL_FUNC)_farray_dropDimension_try);
    R_RegisterCCallable("farray", "_farray_prod2", (DL_FUNC)_farray_prod2_try);
    R_RegisterCCallable("farray", "_farray_parseDots", (DL_FUNC)_farray_parseDots_try);
    R_RegisterCCallable("farray", "_farray_stopIfNot", (DL_FUNC)_farray_stopIfNot_try);
    R_RegisterCCallable("farray", "_farray_getSexpType", (DL_FUNC)_farray_getSexpType_try);
    R_RegisterCCallable("farray", "_farray_tik", (DL_FUNC)_farray_tik_try);
    R_RegisterCCallable("farray", "_farray_tok", (DL_FUNC)_farray_tok_try);
    R_RegisterCCallable("farray", "_farray_RcppExport_validate", (DL_FUNC)_farray_RcppExport_validate);
    return R_NilValue;
}

static const R_CallMethodDef CallEntries[] = {
    {"_farray_isLittleEndian", (DL_FUNC) &_farray_isLittleEndian, 0},
    {"_farray_loc2idx3", (DL_FUNC) &_farray_loc2idx3, 2},
    {"_farray_parseSlices", (DL_FUNC) &_farray_parseSlices, 3},
    {"_farray_parseAndScheduleBlocks2", (DL_FUNC) &_farray_parseAndScheduleBlocks2, 3},
    {"_farray_reshapeOrDrop", (DL_FUNC) &_farray_reshapeOrDrop, 3},
    {"_farray_setFArrayBlockSize", (DL_FUNC) &_farray_setFArrayBlockSize, 3},
    {"_farray_getFArrayBlockSize", (DL_FUNC) &_farray_getFArrayBlockSize, 1},
    {"_farray_subsetFM", (DL_FUNC) &_farray_subsetFM, 6},
    {"_farray_getFArrayThread", (DL_FUNC) &_farray_getFArrayThread, 1},
    {"_farray_setFArrayThread", (DL_FUNC) &_farray_setFArrayThread, 2},
    {"_farray_hasOpenMP", (DL_FUNC) &_farray_hasOpenMP, 0},
    {"_farray_addTo", (DL_FUNC) &_farray_addTo, 2},
    {"_farray_testt", (DL_FUNC) &_farray_testt, 1},
    {"_farray_ensurePartition", (DL_FUNC) &_farray_ensurePartition, 4},
    {"_farray_dropDimension", (DL_FUNC) &_farray_dropDimension, 1},
    {"_farray_prod2", (DL_FUNC) &_farray_prod2, 2},
    {"_farray_parseDots", (DL_FUNC) &_farray_parseDots, 2},
    {"_farray_stopIfNot", (DL_FUNC) &_farray_stopIfNot, 3},
    {"_farray_getSexpType", (DL_FUNC) &_farray_getSexpType, 1},
    {"_farray_tik", (DL_FUNC) &_farray_tik, 0},
    {"_farray_tok", (DL_FUNC) &_farray_tok, 2},
    {"_farray_RcppExport_registerCCallable", (DL_FUNC) &_farray_RcppExport_registerCCallable, 0},
    {NULL, NULL, 0}
};

int detectForked(DllInfo *dll);
RcppExport void R_init_farray(DllInfo *dll) {
    R_registerRoutines(dll, NULL, CallEntries, NULL, NULL);
    R_useDynamicSymbols(dll, FALSE);
    detectForked(dll);
}
